# Operating-Systems-Communica
ΛΕΙΤΟΥΡΓΙΚΆ ΣΥΣΤΉΜΑΤΑ
ΕΡΓΑΣΊΑ 1
Ονοματεπώνυμο: Γεωργόπουλος Ιωάννης
Α. Μ. : 1115201800026
Γενική δομή:
P1.c : Περιέχει τις διεργασίες P1 και ENC1 καθώς και τον κώδικα αυτών
έτσι ώστε να πληρούνται όλες οι απαραίτητες λειτουργίες τους. Η διεργασία
ENC1 δημιουργείται με fork().
P2.c : Περιέχει τις διεργασίες P2 και ENC2 καθώς και τον κώδικα αυτών
έτσι ώστε να πληρούνται όλες οι απαραίτητες λειτουργίες τους. Η διεργασία
ENC2 δημιουργείται με fork().
channel.c : Περιέχει την διεργασία CHANNEL καθώς και τον κώδικα που
χρειάζετα έτσι ώστε να πληρούνται όλες οι απαραίτητες λειτουργίες του.
sharedMemory.h : Περιέχει γενικά τις δηλώσεις συναρτήσεων και
μεταβλητών που ειναι σημαντικές για την εκτέλεση των λειτουργιών
μετάδοσης των μηνυμάτων. Ειδικότερα περιέχει τις δηλωσεις συναρτήσεων
που χρησιμοποιούνται για την διαχείριση της κοινής μνήμης, τα ονόματα των
σημαιοφόρων που χρησιμοποιούνται, το μέγεθος των μπλοκ κοινής μνήμης,
τα ονόματα των μπλοκ κοινής μνήμης, την πιθανότητα λάθους στο CHANNEL
και την τερματική γραμματοσειρά.
sharedMemory.c : Περιέχει τον κώδικα των συναρτήσεων που
χρησιμοποιούνται για την διαχείριση της κοινής μνήμης.
Συγκεκριμένα:
get_shared_block():
Παίρνει το key από το filename με τη
βοήθεια της ftok(), το οποίο (filename) πρέπει να αντιστοιχεί σε
πραγματικό αρχείο μέσα στον φάκελο των αρχείων. Μετά με την
shmget() παίρνει ένα id το οποίο είναι χαρακτηριστικό για το
συγκεκριμένο key.attach_memory_block(): Παίρνει το id του μπλοκ κοινής μνήμης
με τη βοήθεια της get_shared_memory() και του filename και το
χρησιμοποιεί στην συνάρτηση shmat() για να κανει attach σε ένα δείκτη
την διεύθυνση του μπλοκ κοινής μνήμης και επιστρεφει αυτή την τιμη.
detach_memory_block():
Παιρνει τον pointer που δείχνει σε
μπλοκ κοινής μνήμης και το κάνει detach από τον pointer στον οποίο
είχε ανατεθεί προηγουμένως.
destroy_memory_block():
Παίρνει το ονομα ενος μπλοκ κοινής
μνήμης και καταστρέφει το μπλοκ με το συγκεκριμένο όνομα.
Makefile : Περιέχει τον κώδικα μεταγλώττισης του κώδικα.
Παραδοχές υλοποίησης :
Υποθέτω ότι από τις δύο διεργασίες που επικοινωνούν (P1 και P2)πρώτα
στέλνει η μια και μετά η άλλη. Δηλαδή δεν μπορεί να στείλει μια εργασία δύο
συνεχόμενα μηνύματα αλλά πρέπει να περιμένει την άλλη διεργασία να στείλει
έτσι ώστε να ξαναστείλει.
Για την κάθε μονόδρομης μετάδοση δεδομένων από
μια διεργασία σε μια άλλη χρησιμοποιώ δύο σημαιοφόρους
(sem_”sender_proccess”_producer και sem_”receiver_proccess”_consumer).
Αυτό το κάνω έτσι ώστε ο consumer να περιμένει τον producer να βάλει τα
δεδομένα στο μπλοκ κοινής μνήμης πριν τα πάρει αλλά και για να περιμένει ο
producer τον consumer να πάρει τα δεδομένα από το μπλοκ κοινής μνήμης
πριν επιχειρήσει να ξανά βάλει αυτός άλλα δεδομένα.
Οι ENC1 και ENC2 για τον υπολογισμό του checksum χρησιμοποιούν την
συνάρτηση MD5. Έπειτα βάζουν αυτό το checksum δίπλα στο μεταδιδόμενο
μήνυμα, ανάμεσά τους βάζω τον χαρακτήρα “~” έτσι ώστε να μπορώ μετα να
ξεχωρίσω το checksum από το μεταδιδόμενο μήνυμα.
Στο CHANNEL για την πιθανότητα αλλαγής του μηνύματος χρησιμοποίησα
την μεταβλητή  error_probability που εισάγεται από τον χρήστη μέσω
της γραμμης εντολών κατα την εκτελεση του ./channel.out ‘int’ όπου ‘int’
πρέπει είναι ένας ακέραιος αριθμός από το 0 έως και το 99.Διαδικασία αποστολής μηνύματος από μια διεργασία σε μια άλλη:
Έστω ότι P1 στέλνει ένα μήνυμα στον P2. Ξεκινάει ο P1 ζητώντας από τον
χρήστη 1 το μήνυμα που θέλει να στείλει. Παίρνει αυτό το μήνυμα από την
είσοδο και το στέλνει στην διεργασία ENC1 και περιμένει να λάβει από την
ENC1 ένα check value για να δει αν το μήνυμα μεταδόθηκε σωστά ή αν θα
πρεπει να το ξανά στείλει. Η ENC1 με τη σειρά της παίρνει το μήνυμα και
υπολογίζει το MD5 checksum του και το βάζει δίπλα στο μήνυμα και τα
διαχωρίζει με τον χαρακτήρα “~”ανάμεσα τους έτσι ώστε να μπορούν να
διαχωριστούν μετά από την ENC2 . Μετά στέλνει το μήνυμα που τώρα
περιέχει την πληροφορια μαζί με το checksum στην CHANNEL και περιμένει
για ένα check value από την CHANNEL για να το στείλει πίσω στην P1 και αν
χρειάζεται να ξανά λάβει το μήνυμα από την P1. Η CHANNEL σύμφωνα με τη
διαδικασία που αναφέρθηκε παραπάνω υπάρχει περίπτωση να αλλάξει το
μήνυμα. Μετά στέλνει το μήνυμα στην ENC2 και περιμένει το check value για
να το στείλει πίσω στην ENC1 και να δει αν στάλθηκε το μήνυμα σωστά. Ο
ENC2 τώρα λαμβάνει το μήνυμα από τη CHANNEL και βγάζει από μέσα το
μήνυμα και το checksum αυτού. Έπειτα ξανα υπολογίζει το checksum και αν
είναι ίσο με αυτό που έλαβε τότε στέλνει πίσω το check value “1” και συνεχίζει
στέλνοντας στον P2 το τελικό μήνυμα χωρίς το checksum. Η P2 με τη σειρά
της λαμβάνει το μήνυμα από την ENC2 και το εμφανίζει στην οθόνη του
χρήστη 2, μετά θα λάβει θέση έτσι ώστε να στείλει αυτή μήνυμα στην P1. Αν
το checksum που υπολόγισε η ENC2 δεν είναι ίσο με αυτό που έλαβε τότε
στέλνει πίσω το check value “0” και περιμένει να της ξαναστείλει η CHANNEL
το μήνυμα για να δει πάλι αν μεταδόθηκε σωστά. Αυτό θα συνεχίσει να
συμβαινει μέχρι το μυνημα να μεταδοθει σωστά, τότε η ENC2 θα στείλει το
τελικό μήνυμα στην P2 και αυτή θα κάνει ότι αναφέρθηκε παραπάνω. Η
CHANNEL τώρα παίρνει το check value από την ENC2 και το στέλνει πίσω
στην ENC1. Αν το check value είναι “0” τότε θα ξανά περιμένει από την ENC1
το μήνυμα και θα συνεχισει να κανει αυτη τη διαδικασία μέχρι το check value
να είναι “1”. Τώρα η ENC1 παίρνει το check value από την CHANNEL και το
στέλνει στην P1 μετά ελέγχει το check value. Αν είναι “0” τότε περιμένει να της
ξαναστείλει η P1 το μήνυμα για να ξανα υπολογίσει το checksum και να το
ξαναστείλει στο CHANNEL. Αυτό θα συνεχιστεί μέχρι το check value να είναι
“1” τοτε θα επιτραπεί στην ΕNC1 να συνεχίσει και να πάρει θέση για να ερθει
μήνυμα από P2. Τώρα η P1 θα πάρει το check value από την ENC1 και αν
είναι “0” θα ξαναστείλει το μήνυμα στην ENC1, αυτό θα συνεχιστεί μέχρι το
check value να ειναι “1” όταν γίνει αυτό θα επιτραπεί στην P1 να συνεχίσει
έτσι ώστε τώρα αυτή να γίνει receiver και η P2 sender. Όταν τελειωσουν όλες
οι διεργασίες την P1 σε P2 μετάδοση ελέγχεται από όλες αν το μήνυμα που
στάλθηκε είναι ίσο με το TERMINATION_STRING με τη βοήθεια του
end_string που αποθηκεύει το μήνυμα.Μεταγλώττιση και εκτέλεση:
Μεταγλώττιση : Η μεταγλώττιση γίνεται με τη βοήθεια του Makefile πατώντας
“make” στο terminal. Υπάρχει επίσης η επιλογή να καθαρισουμε τα αρχεία με
την εντολή “make clean”.
Eκτέλεση: Για την εκτέλεση των προγραμμάτων θα πρέπει να ανοιχτούν τρία
terminals. Στο πρώτο εκτελουμε το ./P1.out στο δεύτερο το ./P2.out και στο
τρίτο το ./channel.out ‘int’ όπου ‘int’ πρέπει είναι ένας ακέραιος αριθμός από
το 0 έως και το 99. Δεν έχει σημασία η σειρά που θα εκτελεστούν αυτά τα τρία
εκτελουμενα αρχεία αρκεί να εκτελεστούν ολα πριν αρχίσει η επικοινωνία
μεταξύ P1 και P2. Επίσης ο P1 ξεκινάει πρωτος όπως αναφέρθηκε
παραπάνω στις παραδοχές. Για τον τερματισμό αρκεί να σταλεί η
γραμματοσειρά “TERM” από την P1 αν είναι η σειρά της P1, ή από την P2 αν
είναι η σειρά της P2. Κάθε διεργασία θα εμφανίσει αντίστοιχο μήνυμα ότι
τερματίζει πριν τερματίσει.
